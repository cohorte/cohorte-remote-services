/**
 * Copyright 2014 isandlaTech
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.cohorte.ecf.provider.jabsorb.host;

import java.util.Dictionary;
import java.util.LinkedHashMap;
import java.util.Map;

import org.cohorte.ecf.provider.jabsorb.Activator;
import org.cohorte.ecf.provider.jabsorb.JabsorbConstants;
import org.cohorte.ecf.provider.jabsorb.Utilities;
import org.eclipse.ecf.core.identity.ID;
import org.eclipse.ecf.core.util.ECFException;
import org.eclipse.ecf.remoteservice.IOSGiRemoteServiceContainerAdapter;
import org.eclipse.ecf.remoteservice.IRemoteServiceListener;
import org.eclipse.ecf.remoteservice.IRemoteServiceReference;
import org.eclipse.ecf.remoteservice.IRemoteServiceRegistration;
import org.eclipse.ecf.remoteservice.events.IRemoteServiceEvent;
import org.eclipse.ecf.remoteservice.events.IRemoteServiceUnregisteredEvent;
import org.eclipse.ecf.remoteservice.servlet.ServletServerContainer;
import org.osgi.framework.ServiceReference;

/**
 * Jabsorb ECF host container: registers services to the Jabsorb bridge
 * 
 * @author Thomas Calmant
 */
public class JabsorbHostContainer extends ServletServerContainer implements
        IOSGiRemoteServiceContainerAdapter, IRemoteServiceListener {

    /** The Jabsorb bridge */
    private JabsorbHttpServiceComponent pBridge;

    /** The endpoint name */
    private String pEndpointName;

    /** Exported service reference */
    private IRemoteServiceReference pExportedReference;

    /** Service reference */
    private ServiceReference<?> pReference;

    /**
     * @param aId
     *            The host container ID, as generated by the
     *            JabsorbContainerInstantiator
     */
    public JabsorbHostContainer(final ID aId,
            final JabsorbHttpServiceComponent aBridge) {

        super(aId);
        pBridge = aBridge;
        addRemoteServiceListener(this);
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * org.eclipse.ecf.remoteservice.servlet.ServletServerContainer#dispose()
     */
    @Override
    public void dispose() {

        // Unregister the service, if needed
        unregisterService();

        // Clean up
        pBridge = null;
        super.dispose();
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * org.eclipse.ecf.remoteservice.IRemoteServiceListener#handleServiceEvent
     * (org.eclipse.ecf.remoteservice.events.IRemoteServiceEvent)
     */
    @Override
    public void handleServiceEvent(final IRemoteServiceEvent aEvent) {

        if (aEvent instanceof IRemoteServiceUnregisteredEvent) {
            // Got an unregistration event...
            if (aEvent.getReference().equals(pExportedReference)) {
                // ... which matches our service
                unregisterService();
            }
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see org.eclipse.ecf.remoteservice.IOSGiRemoteServiceContainerAdapter#
     * registerRemoteService(java.lang.String[],
     * org.osgi.framework.ServiceReference, java.util.Dictionary)
     */
    @SuppressWarnings("rawtypes")
    @Override
    public IRemoteServiceRegistration registerRemoteService(
            final String[] aClazzes, final ServiceReference aServiceReference,
            final Dictionary aProperties) {

        // Compute the endpoint name
        try {
            pEndpointName = Utilities.getEndpointName(aServiceReference);

        } catch (final ECFException ex) {
            throw new IllegalArgumentException(
                    "Can't generate an endpoint name", ex);
        }

        // Grab the service
        pReference = aServiceReference;
        final Object service = Activator.get().getContext()
                .getService(pReference);

        // Register the service to the bridge
        pBridge.registerEndpoint(pEndpointName, service);

        // Call the parent to make the registration bean
        // ... properties not given to the endpoint description...
        final IRemoteServiceRegistration registration = super
                .registerRemoteService(aClazzes, service, aProperties);

        // Keep the service reference
        pExportedReference = registration.getReference();

        // Prepare Jabsorb provider properties
        final Map<String, Object> extraProperties = new LinkedHashMap<String, Object>();

        // ... endpoint name
        extraProperties.put(JabsorbConstants.PROP_ENDPOINT_NAME, pEndpointName);

        // ... HTTP accesses
        final String accessesStr = Utilities
                .makeAccesses(pBridge.getAccesses());
        extraProperties.put(JabsorbConstants.PROP_HTTP_ACCESSES, accessesStr);

        // Return an extended registration, to add some properties to the
        // endpoint description
        return new ExtendedRemoteServiceRegistration(registration,
                extraProperties);
    }

    /**
     * Unregisters the exported service from Jabsorb and releases it
     */
    private synchronized void unregisterService() {

        // Unregister the endpoint from Jabsorb
        if (pEndpointName != null) {
            pBridge.unregisterEndpoint(pEndpointName);
        }

        // Release the service
        if (pReference != null) {
            Activator.get().getContext().ungetService(pReference);
        }

        Utilities.traceDebug("unregisterService", getClass(),
                "Service at endpoint " + pEndpointName + " unregistered");

        // Clean up
        pEndpointName = null;
        pExportedReference = null;
        pReference = null;
    }
}
